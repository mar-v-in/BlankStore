// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: proto/Offers.proto
package com.google.play.proto;

import com.squareup.wire.Message;
import com.squareup.wire.ProtoField;
import java.util.Collections;
import java.util.List;

import static com.squareup.wire.Message.Datatype.BOOL;
import static com.squareup.wire.Message.Datatype.DOUBLE;
import static com.squareup.wire.Message.Datatype.FIXED64;
import static com.squareup.wire.Message.Datatype.INT32;
import static com.squareup.wire.Message.Datatype.INT64;
import static com.squareup.wire.Message.Datatype.STRING;
import static com.squareup.wire.Message.Label.REPEATED;

public final class Rule extends Message {

  public static final Boolean DEFAULT_NEGATE = false;
  public static final Integer DEFAULT_OPERATOR = 0;
  public static final Integer DEFAULT_KEY = 0;
  public static final List<String> DEFAULT_STRINGARG = Collections.emptyList();
  public static final List<Long> DEFAULT_LONGARG = Collections.emptyList();
  public static final List<Double> DEFAULT_DOUBLEARG = Collections.emptyList();
  public static final List<Rule> DEFAULT_SUBRULE = Collections.emptyList();
  public static final Integer DEFAULT_RESPONSECODE = 0;
  public static final String DEFAULT_COMMENT = "";
  public static final List<Long> DEFAULT_STRINGARGHASH = Collections.emptyList();
  public static final List<Integer> DEFAULT_CONSTARG = Collections.emptyList();

  @ProtoField(tag = 1, type = BOOL)
  public final Boolean negate;

  @ProtoField(tag = 2, type = INT32)
  public final Integer operator;

  @ProtoField(tag = 3, type = INT32)
  public final Integer key;

  @ProtoField(tag = 4, type = STRING, label = REPEATED)
  public final List<String> stringArg;

  @ProtoField(tag = 5, type = INT64, label = REPEATED)
  public final List<Long> longArg;

  @ProtoField(tag = 6, type = DOUBLE, label = REPEATED)
  public final List<Double> doubleArg;

  @ProtoField(tag = 7, label = REPEATED)
  public final List<Rule> subrule;

  @ProtoField(tag = 8, type = INT32)
  public final Integer responseCode;

  @ProtoField(tag = 9, type = STRING)
  public final String comment;

  @ProtoField(tag = 10, type = FIXED64, label = REPEATED)
  public final List<Long> stringArgHash;

  @ProtoField(tag = 11, type = INT32, label = REPEATED)
  public final List<Integer> constArg;

  public Rule(Boolean negate, Integer operator, Integer key, List<String> stringArg, List<Long> longArg, List<Double> doubleArg, List<Rule> subrule, Integer responseCode, String comment, List<Long> stringArgHash, List<Integer> constArg) {
    this.negate = negate;
    this.operator = operator;
    this.key = key;
    this.stringArg = immutableCopyOf(stringArg);
    this.longArg = immutableCopyOf(longArg);
    this.doubleArg = immutableCopyOf(doubleArg);
    this.subrule = immutableCopyOf(subrule);
    this.responseCode = responseCode;
    this.comment = comment;
    this.stringArgHash = immutableCopyOf(stringArgHash);
    this.constArg = immutableCopyOf(constArg);
  }

  private Rule(Builder builder) {
    this(builder.negate, builder.operator, builder.key, builder.stringArg, builder.longArg, builder.doubleArg, builder.subrule, builder.responseCode, builder.comment, builder.stringArgHash, builder.constArg);
    setBuilder(builder);
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof Rule)) return false;
    Rule o = (Rule) other;
    return equals(negate, o.negate)
        && equals(operator, o.operator)
        && equals(key, o.key)
        && equals(stringArg, o.stringArg)
        && equals(longArg, o.longArg)
        && equals(doubleArg, o.doubleArg)
        && equals(subrule, o.subrule)
        && equals(responseCode, o.responseCode)
        && equals(comment, o.comment)
        && equals(stringArgHash, o.stringArgHash)
        && equals(constArg, o.constArg);
  }

  @Override
  public int hashCode() {
    int result = hashCode;
    if (result == 0) {
      result = negate != null ? negate.hashCode() : 0;
      result = result * 37 + (operator != null ? operator.hashCode() : 0);
      result = result * 37 + (key != null ? key.hashCode() : 0);
      result = result * 37 + (stringArg != null ? stringArg.hashCode() : 1);
      result = result * 37 + (longArg != null ? longArg.hashCode() : 1);
      result = result * 37 + (doubleArg != null ? doubleArg.hashCode() : 1);
      result = result * 37 + (subrule != null ? subrule.hashCode() : 1);
      result = result * 37 + (responseCode != null ? responseCode.hashCode() : 0);
      result = result * 37 + (comment != null ? comment.hashCode() : 0);
      result = result * 37 + (stringArgHash != null ? stringArgHash.hashCode() : 1);
      result = result * 37 + (constArg != null ? constArg.hashCode() : 1);
      hashCode = result;
    }
    return result;
  }

  public static final class Builder extends Message.Builder<Rule> {

    public Boolean negate;
    public Integer operator;
    public Integer key;
    public List<String> stringArg;
    public List<Long> longArg;
    public List<Double> doubleArg;
    public List<Rule> subrule;
    public Integer responseCode;
    public String comment;
    public List<Long> stringArgHash;
    public List<Integer> constArg;

    public Builder() {
    }

    public Builder(Rule message) {
      super(message);
      if (message == null) return;
      this.negate = message.negate;
      this.operator = message.operator;
      this.key = message.key;
      this.stringArg = copyOf(message.stringArg);
      this.longArg = copyOf(message.longArg);
      this.doubleArg = copyOf(message.doubleArg);
      this.subrule = copyOf(message.subrule);
      this.responseCode = message.responseCode;
      this.comment = message.comment;
      this.stringArgHash = copyOf(message.stringArgHash);
      this.constArg = copyOf(message.constArg);
    }

    public Builder negate(Boolean negate) {
      this.negate = negate;
      return this;
    }

    public Builder operator(Integer operator) {
      this.operator = operator;
      return this;
    }

    public Builder key(Integer key) {
      this.key = key;
      return this;
    }

    public Builder stringArg(List<String> stringArg) {
      this.stringArg = checkForNulls(stringArg);
      return this;
    }

    public Builder longArg(List<Long> longArg) {
      this.longArg = checkForNulls(longArg);
      return this;
    }

    public Builder doubleArg(List<Double> doubleArg) {
      this.doubleArg = checkForNulls(doubleArg);
      return this;
    }

    public Builder subrule(List<Rule> subrule) {
      this.subrule = checkForNulls(subrule);
      return this;
    }

    public Builder responseCode(Integer responseCode) {
      this.responseCode = responseCode;
      return this;
    }

    public Builder comment(String comment) {
      this.comment = comment;
      return this;
    }

    public Builder stringArgHash(List<Long> stringArgHash) {
      this.stringArgHash = checkForNulls(stringArgHash);
      return this;
    }

    public Builder constArg(List<Integer> constArg) {
      this.constArg = checkForNulls(constArg);
      return this;
    }

    @Override
    public Rule build() {
      return new Rule(this);
    }
  }
}
